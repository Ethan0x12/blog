---
title: Web3.js与Ethers.js全面对比：区块链交互核心库详解
publishedAt: 2025-10-16
summary: 深入对比Web3.js与Ethers.js两大区块链交互库的特性、API设计、使用方法与最佳实践

tags:
  - web3
  - 区块链开发
  - 以太坊交互
---

# Web3.js与Ethers.js全面对比：区块链交互核心库详解

在Web3前端开发中，与区块链进行交互是核心功能之一。目前，Web3.js和Ethers.js是开发者最常用的两个JavaScript库，用于与以太坊网络进行通信。本文将深入对比这两个库的特性、架构设计和使用方法，帮助开发者根据项目需求选择合适的工具。

## 1. Web3.js：以太坊官方JavaScript API

### 1.1 基础架构

Web3.js是由以太坊基金会开发的官方JavaScript API，设计用于与以太坊区块链进行交互。它提供了一个完整的接口，允许开发者执行各种操作，从简单的账户查询到复杂的智能合约交互。

### 1.2 核心API组件

#### Web3实例初始化

```javascript
const Web3 = require('web3');
// 通过HTTP提供者连接
const web3 = new Web3('https://mainnet.infura.io/v3/YOUR_INFURA_KEY');
// 或通过Websocket提供者连接
const web3 = new Web3('wss://mainnet.infura.io/ws/v3/YOUR_INFURA_KEY');
// 或从MetaMask等钱包获取提供者
const web3 = new Web3(window.ethereum);
```

#### 账户操作

Web3.js提供了丰富的账户管理功能，包括账户创建、余额查询和交易签名：

```javascript
// 查询账户余额
async function getBalance(address) {
  const balance = await web3.eth.getBalance(address);
  return web3.utils.fromWei(balance, 'ether');
}

// 创建新账户
function createAccount() {
  const account = web3.eth.accounts.create();
  console.log('地址:', account.address);
  console.log('私钥:', account.privateKey);
  return account;
}

// 使用私钥签署交易
async function signTransaction(privateKey) {
  const account = web3.eth.accounts.privateKeyToAccount(privateKey);
  const tx = {
    to: '0xReceiverAddress',
    value: web3.utils.toWei('1', 'ether'),
    gas: 21000
  };
  const signedTx = await account.signTransaction(tx);
  return signedTx;
}
```

#### 合约交互

与智能合约交互是Web3.js的核心功能之一：

```javascript
// 定义合约ABI（应用程序二进制接口）
const contractABI = [...]; // 合约ABI数组
// 合约地址
const contractAddress = '0xContractAddress';
// 创建合约实例
const contract = new web3.eth.Contract(contractABI, contractAddress);

// 调用只读方法（无需Gas）
async function callContractMethod() {
  const result = await contract.methods.someMethod(param1, param2).call();
  return result;
}

// 发送交易执行状态变更方法（需要Gas）
async function sendContractTransaction(fromAddress, privateKey) {
  const tx = contract.methods.someMethod(param1, param2);
  const gas = await tx.estimateGas({ from: fromAddress });
  const gasPrice = await web3.eth.getGasPrice();
  const data = tx.encodeABI();
  const nonce = await web3.eth.getTransactionCount(fromAddress);
  
  const signedTx = await web3.eth.accounts.signTransaction(
    {
      to: contractAddress,
      data,
      gas,
      gasPrice,
      nonce
    },
    privateKey
  );
  
  const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);
  return receipt;
}
```

## 2. Ethers.js：现代以太坊交互库

### 2.1 核心架构设计

Ethers.js采用了模块化设计，主要由Provider、Signer和Contract三个核心对象组成，这种设计使得代码更加清晰和可维护。

### 2.2 核心对象详解

#### Provider对象

Provider负责与区块链网络通信，用于读取链上数据：

```javascript
const { ethers } = require('ethers');

// 创建Provider实例
const provider = new ethers.providers.JsonRpcProvider('https://mainnet.infura.io/v3/YOUR_INFURA_KEY');
// 或使用Websocket
const wsProvider = new ethers.providers.WebSocketProvider('wss://mainnet.infura.io/ws/v3/YOUR_INFURA_KEY');
// 或从MetaMask获取
const provider = new ethers.providers.Web3Provider(window.ethereum);

// 使用Provider查询数据
async function getBlockInfo() {
  const blockNumber = await provider.getBlockNumber();
  const block = await provider.getBlock(blockNumber);
  return { blockNumber, block };
}
```

#### Signer对象

Signer负责交易签名和发送，代表一个以太坊账户：

```javascript
// 从私钥创建Signer
const privateKey = '0xYOUR_PRIVATE_KEY';
const wallet = new ethers.Wallet(privateKey, provider);

// 或从Provider获取Signer（如MetaMask）
const signer = provider.getSigner();

// 查询余额
async function getWalletBalance() {
  const balance = await wallet.getBalance();
  return ethers.utils.formatEther(balance);
}

// 发送以太币
async function sendEther(toAddress, amountInEther) {
  const tx = await wallet.sendTransaction({
    to: toAddress,
    value: ethers.utils.parseEther(amountInEther)
  });
  await tx.wait(); // 等待交易确认
  return tx;
}
```

#### Contract对象

Contract对象用于与智能合约交互，结合了Provider的读取功能和Signer的写入功能：

```javascript
// 创建合约实例（只读）
const contractAddress = '0xContractAddress';
const contractABI = [...]; // 合约ABI
const contract = new ethers.Contract(contractAddress, contractABI, provider);

// 创建合约实例（可写）
const contractWithSigner = contract.connect(wallet);

// 调用只读方法
async function callContractMethod() {
  const result = await contract.someMethod(param1, param2);
  return result;
}

// 发送交易执行状态变更方法
async function executeContractMethod() {
  const tx = await contractWithSigner.someMethod(param1, param2);
  await tx.wait(); // 等待交易确认
  return tx;
}
```

## 3. 读取链上数据：区块、交易和合约状态

### 3.1 查询区块信息

#### Web3.js实现

```javascript
async function getBlockDetails(blockNumberOrHash) {
  // 获取区块信息
  const block = await web3.eth.getBlock(blockNumberOrHash);
  
  // 获取交易详情
  const transactions = await Promise.all(
    block.transactions.map(txHash => web3.eth.getTransaction(txHash))
  );
  
  return { block, transactions };
}
```

#### Ethers.js实现

```javascript
async function getBlockDetails(blockNumberOrHash) {
  // 获取区块信息
  const block = await provider.getBlock(blockNumberOrHash, true); // true表示包含完整交易信息
  return block;
}
```

### 3.2 查询交易信息

#### Web3.js实现

```javascript
async function getTransactionDetails(txHash) {
  // 获取交易信息
  const tx = await web3.eth.getTransaction(txHash);
  
  // 获取交易收据
  const receipt = await web3.eth.getTransactionReceipt(txHash);
  
  return { tx, receipt };
}
```

#### Ethers.js实现

```javascript
async function getTransactionDetails(txHash) {
  // 获取交易信息
  const tx = await provider.getTransaction(txHash);
  
  // 获取交易收据
  const receipt = await provider.getTransactionReceipt(txHash);
  
  return { tx, receipt };
}
```

### 3.3 查询合约状态

#### Web3.js实现

```javascript
async function getContractState(contract) {
  // 假设合约有这些状态查询方法
  const name = await contract.methods.name().call();
  const symbol = await contract.methods.symbol().call();
  const totalSupply = await contract.methods.totalSupply().call();
  
  return { name, symbol, totalSupply };
}
```

#### Ethers.js实现

```javascript
async function getContractState(contract) {
  // 调用合约方法直接映射到JavaScript对象属性
  const name = await contract.name();
  const symbol = await contract.symbol();
  const totalSupply = await contract.totalSupply();
  
  return { name, symbol, totalSupply };
}
```

## 4. 写入链上数据：发送交易和调用合约方法

### 4.1 发送原生代币（ETH）

#### Web3.js实现

```javascript
async function sendEtherWeb3(fromAddress, toAddress, amountInEther, privateKey) {
  // 准备交易对象
  const txObject = {
    from: fromAddress,
    to: toAddress,
    value: web3.utils.toWei(amountInEther, 'ether'),
    gas: 21000, // 基础转账固定gas
    gasPrice: await web3.eth.getGasPrice()
  };
  
  // 签名交易
  const signedTx = await web3.eth.accounts.signTransaction(txObject, privateKey);
  
  // 发送交易
  const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);
  return receipt;
}
```

#### Ethers.js实现

```javascript
async function sendEtherEthers(wallet, toAddress, amountInEther) {
  const tx = await wallet.sendTransaction({
    to: toAddress,
    value: ethers.utils.parseEther(amountInEther)
  });
  
  await tx.wait(); // 等待交易确认
  return tx;
}
```

### 4.2 调用合约方法（修改状态）

#### Web3.js实现

```javascript
async function executeContractFunctionWeb3(contract, functionName, params, fromAddress, privateKey) {
  // 编码交易数据
  const data = contract.methods[functionName](...params).encodeABI();
  
  // 估算gas
  const gas = await contract.methods[functionName](...params).estimateGas({ from: fromAddress });
  
  // 准备交易对象
  const txObject = {
    from: fromAddress,
    to: contract.options.address,
    data,
    gas,
    gasPrice: await web3.eth.getGasPrice(),
    nonce: await web3.eth.getTransactionCount(fromAddress)
  };
  
  // 签名交易
  const signedTx = await web3.eth.accounts.signTransaction(txObject, privateKey);
  
  // 发送交易
  const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);
  return receipt;
}
```

#### Ethers.js实现

```javascript
async function executeContractFunctionEthers(contractWithSigner, functionName, params) {
  // 直接调用合约方法
  const tx = await contractWithSigner[functionName](...params);
  
  // 等待交易确认
  await tx.wait();
  return tx;
}
```

## 5. 事件监听：监听合约事件和区块更新

### 5.1 监听区块更新

#### Web3.js实现

```javascript
// 监听新区块
const subscription = web3.eth.subscribe('newBlockHeaders', (error, blockHeader) => {
  if (error) {
    console.error('订阅错误:', error);
    return;
  }
  console.log('新区块:', blockHeader.number);
});

// 在需要时取消订阅
// subscription.unsubscribe((error, success) => {
//   if (success) {
//     console.log('成功取消订阅');
//   }
// });
```

#### Ethers.js实现

```javascript
// 监听区块号变化
provider.on('block', (blockNumber) => {
  console.log('新区块:', blockNumber);
});

// 监听链状态变化
provider.on('network', (newNetwork, oldNetwork) => {
  // 当网络改变时，provider需要重置
  if (oldNetwork) {
    window.location.reload();
  }
  console.log('新网络:', newNetwork.name);
});
```

### 5.2 监听合约事件

#### Web3.js实现

```javascript
// 定义要监听的事件过滤器
const eventFilter = {
  filter: { /* 过滤条件 */ },
  fromBlock: 0 // 从哪个区块开始监听
};

// 监听合约事件
contract.events.Transfer(eventFilter)
  .on('data', (event) => {
    console.log('事件数据:', event.returnValues);
    // 处理事件...
  })
  .on('error', (error) => {
    console.error('事件监听错误:', error);
  });

// 查询历史事件
async function getPastEvents() {
  const events = await contract.getPastEvents('Transfer', {
    filter: { /* 过滤条件 */ },
    fromBlock: 0,
    toBlock: 'latest'
  });
  return events;
}
```

#### Ethers.js实现

```javascript
// 监听合约事件
contract.on('Transfer', (from, to, amount, event) => {
  console.log('转账事件:', {
    from,
    to,
    amount: ethers.utils.formatUnits(amount, 18),
    transactionHash: event.transactionHash
  });
});

// 查询历史事件
async function getPastEvents() {
  const filter = contract.filters.Transfer(null, null); // 所有转账事件
  const events = await contract.queryFilter(filter, 0, 'latest');
  return events;
}
```

## 6. Web3.js与Ethers.js对比分析

### 6.1 设计理念对比

| 特性 | Web3.js | Ethers.js |
|------|---------|-----------|
| 架构设计 | 整体式API，单一入口 | 模块化设计，Provider/Signer/Contract分离 |
| 代码体积 | 较大 | 较小，更轻量 |
| 文档质量 | 官方但有时不够清晰 | 结构良好，文档详尽 |
| 开发活跃度 | 活跃 | 非常活跃，定期更新 |
| 学习曲线 | 相对平缓，但API设计不够一致 | 更清晰，但需要理解核心对象概念 |

### 6.2 性能与体积对比

- **Web3.js**：完整包大小约为1MB+，加载时间较长，在资源受限的环境中可能影响性能。
- **Ethers.js**：模块化设计允许只引入需要的部分，完整包大小约为300KB，加载和执行更快。

### 6.3 安全考量

- **Web3.js**：早期版本存在一些安全问题，但近期版本已大幅改进。
- **Ethers.js**：设计时更注重安全性，默认实现了更多安全检查，如交易参数验证。

### 6.4 使用场景推荐

- **Web3.js**：适合需要完整功能集的大型应用，或者团队已经熟悉该库的项目。
- **Ethers.js**：适合注重性能的前端应用、移动应用，以及需要更清晰API设计的新项目。

## 7. 最佳实践与选择建议

### 7.1 开发建议

1. **新项目选择**：如果是新项目，建议考虑Ethers.js，尤其是对于前端性能敏感的应用。
2. **与钱包集成**：两种库都可以轻松与MetaMask等钱包集成，但Ethers.js的Provider抽象使得适配不同钱包更加统一。
3. **性能优化**：
   - 使用Web3.js时，考虑按需导入模块而非整个库
   - 使用Ethers.js时，利用其模块化设计，只引入必要组件
4. **错误处理**：始终实现全面的错误处理，特别是在交易发送和事件监听过程中

### 7.2 安全最佳实践

1. **私钥管理**：绝不在前端代码中硬编码私钥
2. **Gas估算**：始终在发送交易前估算Gas
3. **交易确认**：实现交易确认机制，不要假设交易立即成功
4. **签名验证**：实现签名消息验证，确保数据完整性

## 8. 结论

Web3.js和Ethers.js都是功能强大的以太坊交互库，各有优势。Web3.js作为官方库，生态系统支持广泛，而Ethers.js则以其模块化设计、轻量级和现代API赢得了开发者的青睐。

在选择时，应考虑项目需求、团队熟悉度和性能要求。无论选择哪个库，都应遵循安全最佳实践，确保与区块链交互的安全性和可靠性。

随着以太坊生态系统的不断发展，这两个库也在持续更新和改进，作为Web3开发者，掌握这些工具将帮助你更高效地构建去中心化应用。